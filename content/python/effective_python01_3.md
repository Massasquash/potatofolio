---
title: "[Effective Python]03 str型とbytes型"
date: 2021-01-01T01:03
lead: "「Effective python第２版」の学習備忘録"
categories:
  - "Python「Effective Python 2th」"
---

# はじめに
この記事は「Effective Python 第二版」の学習の備忘録です。
今回は**１章 Pythonic思考**の項目3です。

## 項目3 bytesとstrの違いを知っておく
Python3では、文字列データ型を表すのにbytes型とstr型の２種類の組み込み型があります。  
bytes型は「バイナリデータ」でstr型は「テキストデータ」に当たります。bytesは8ビット値の列を含み、strはUnicodeコードポイント（割り振られている番号のこと）の文字列を含む、と表現されています。  
それぞれの型は似たような文字列を出力できますが、演算子で一緒に扱うことが一緒にできないので注意が必要、とのことです。


## 解説
str型とbytes型については僕の今の知識ではあまり理解ができなかったので、ここでは前提知識を整理してみました。  
コンピュータの全般的な知識として、テキストデータとバイナリデータという考え方と、エンコーディングというものがあるので、それらについて整理します。

### （１）テキストデータとバイナリデータ
パソコンで扱うことのできるファイルは大きく分けるとこの２種類になります。  

- 「テキストデータ」は、メモ帳などのテキストエディタで開くことができる、僕らが読めるような文字データ
- 「バイナリデータ」は、そのほか画像、動画、圧縮ファイルなど文字以外を扱っている他の全てのデータ

これはコンピュータの仕組みによる区別です。  
コンピュータが処理することのできるデータは、0か1の集まりである「バイナリコード」になります。この0か1という最小単位がビットで、8ビットをひとまとまりにしたバイトという単位が使われています。  

このような0と1からなるビットで構成されているデータが、コンピュータが読める「バイナリデータ」です。  
一方で、このデータは僕らが目で見ても解読不能なので、日本語なりなんなりの文字で書かれている必要があります。  
そのビットと文字との対応表である「文字コード表」を作ることで、僕らが理解できる「テキストデータ」に変換することができます。  

厳密にいうと、テキストデータもバイナリデータの一種です。

### （２）文字コード表とエンコード
0と1からなるバイナリデータから、人間の読めるテキストデータに翻訳するためにあるのが「文字コード表」です。  
そしてこの文字コード表に基づいて翻訳する作業のことを「エンコード」と呼びます。エンコードするときに、どの文字コード表を元にデータを変換するのかを指定します。

よく文字化けの問題が起こりますが、その原因がここにあります。翻訳に使用すべき文字コード表と、実際に使用する文字コード表が違ってしまっているのが原因です。  

**文字コードの種類**
| 文字コード | 解説 |
| :--- | :--- |
| ASCIIコード | アルファベット、数字、記号、空白文字、制御文字などを表現。ISOで国際標準になっている |
| Unicode | アルファベット、漢字、カナ、アラビア文字など世界中の文字を表現。ISOで規格化されている |

書籍のこの項目の最後の方に「cp1252」という文字コードが出てきますが、これはラテン文字との対応づけをするためのコード表、かと思います。

参考： [よく使われる文字コード一覧と特徴 | UX MILK](https://uxmilk.jp/46875)

**エンコードとデコード**
どちらがどちらか案外こんがらがってしまう言葉です。

- 「エンコード」は元のデータを別のフォーマットに変換すること。符号化、変換、圧縮
- 「デコード」は元のデータに戻すこと。復号化、解析

動画のファイル変換をするときにもエンコード、デコードという表現がよく使われますね。


### （３）Python3におけるbytes型とstr型
次はPython3でのbytesとstrについて整理しておきます。  

こちら、[Pythonのstr型とbytes型 | KISO-REN](https://www.kannon.link/fuku/index.php/2017/02/22/01-34/)の記事がとてもわかりやすく整理されていました。

ここではざっくり、bytes型とstr型はどちらも文字列データを表しています。

書籍の表現を抜き出してみると、

> bytesのインスタンスは、生の符号なし8ビット値からなり、通常はASCIIエンコーディングで表示されます
> strのインスタンスはテキスト文字を表すUnicodeコードポイントを含みます
> strインスタンスはバイナリエンコーディングを持たず、bytesインスタンスはテキストエンコーディングを持たない

また、公式ドキュメントも並べて記述してみると、

**テキストシーケンス型 --- str**
[組み込み型 — Python 3.9.1 ドキュメント](https://docs.python.org/ja/3/library/stdtypes.html#text-sequence-type-str)
>Python のテキストデータは str オブジェクト、すなわち 文字列 として扱われます。文字列は Unicode コードポイントのイミュータブルな シーケンス です。


**バイナリシーケンス型 --- bytes**
[組み込み型 — Python 3.9.1 ドキュメント](https://docs.python.org/ja/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview)
>bytes はバイトの不変なシーケンスです。多くのメジャーなプロトコルがASCIIテキストエンコーディングをベースにしているので、 bytes オブジェクトは ASCII 互換のデータに対してのみ動作する幾つかのメソッドを提供していて、文字列オブジェクトと他の多くの点で近いです。

表現がだいぶ難しいですが、

- str型は文字変換される一歩手前の「Unicodeコードポイント」（文字と対応づけされた番号）の状態で保持されていて、`print()`で出力されるときにエンコードされて僕らが読める文字列が出力される
- bytes型は符号なし8ビット値というコンピュータが読める値で保持されていて、`print()`で出力されるときには「ASCIIコード」でエンコードされて僕らが読める文字列として出力される

と言うことでしょうか…？（間違っていたらすみません）  
strからbytesに変換することをエンコード、bytesからstrに変換することがデコードに当たるようです。  

また、それぞれのリテラルの書き方を整理すると、

**bytes**
リテラルは`b'hogehoge'`, `b"hogehoge"`のように、シングルかダブルクォーテーションで文字列を囲い、その前に`b`を添えて書きます。

**str**
リテラルは`hogehoge`, `"hogehoge"`のように、シングルかダブルクォーテーションで文字列を囲って書きます。

このように表記がとても似ています。  

Python3ではこれらは似たような文字列型として扱えるのですが、例えばbytesとstrの`+`演算、比較の`>`,`==`演算などができなかったりと、型の違いによって細かな違いがあるので、注意が必要とのことです。

## 感想
かなり難しい内容に感じて、だいぶ端折って解説してしまいました。  
書籍の中では`open()`関数でモード指定（テキストモードかバイナリモードか）と言うような話もあり、もうちょっと踏み込んだ解説がされているのかな、と思います。

エンコーディングといえば文字化けの問題、例えばスクレイピングで取得したデータやダウンロードしてきたCSVをmacで開くのとwindowsで開くとで、同じように開けずどちらかが文字化けしている…と言う問題に出くわしたことがあります。  
プログラミングにおいて避けては通れない問題になるので、難しいなりにイメージをつかんでおくだけでも大事な項目なのかな、と思いました。


---
## MEMO
【参考ページ】
- [コンピュータの仕組み ～テキストファイルとバイナリファイル～｜カルテットコミュニケーションズ](https://quartet-communications.com/info/topics/3182#:~:text=%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AB%E3%81%AF2%E7%A8%AE%E9%A1%9E%E3%81%97%E3%81%8B%E3%81%AA%E3%81%84,-%E3%83%91%E3%82%BD%E3%82%B3%E3%83%B3%E3%81%A7%E6%89%B1%E3%81%86&text=%E3%81%99%E3%81%AA%E3%82%8F%E3%81%A1%E3%80%81%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A8%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A7%E3%81%99%E3%80%82&text=%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%AF%E3%80%81%20%E6%96%87%E5%AD%97,%E6%9B%B8%E3%81%8B%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%80%82&text=%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%AF%E3%80%81%20%E3%81%9D%E3%82%8C%E4%BB%A5%E5%A4%96%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%99%E3%81%B9%E3%81%A6%E3%80%82)
- [よく使われる文字コード一覧と特徴 | UX MILK](https://uxmilk.jp/46875)
- [「エンコード」と「デコード」の違い｜「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/diff397data.html)

- [Pythonのstr型とbytes型 | KISO-REN](https://www.kannon.link/fuku/index.php/2017/02/22/01-34/)

【書籍】
- Effective Python 第2版 ―Pythonプログラムを改良する90項目
<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=massasquash08-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=4873119170&linkId=b01ad363c615cc9408dfcc360b1a85de&bc1=ffffff&amp;lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"></iframe>

---